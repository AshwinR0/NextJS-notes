## Next.js In-Depth Notes for the Senior Frontend Developer: Routing

### 1. Introduction to Next.js Routing (App Router)

For a senior developer, understanding Next.js's App Router is key to grasping its modern architecture. It's a significant evolution from the Pages Router, built on top of React Server Components, and offers more flexibility and power.

**Core Concept: File-Based Routing**

Next.js employs a file-system-based router. This means the structure of your folders and files within the `app` directory directly maps to the URL structure of your application. This convention-over-configuration approach simplifies route management.

*   **Folders define routes**: Each folder represents a URL segment.
*   **`page.tsx` creates the UI**: A file named `page.tsx` (or `page.js`) within a folder makes that route publicly accessible and defines its UI.

#### Setting Up a New Next.js Project

When you initialize a new project with `npx create-next-app@latest`, you'll be prompted to use the **App Router**, which is the recommended setup.

#### Understanding File-Based Routing

The logic is intuitive: the file path in your `app` directory becomes the URL path.

#### Creating Your First Route

1.  When a new Next.js project is created, an `app/page.tsx` file is generated by default. This file corresponds to the root URL of your site (`/`).
2.  To create a new route, such as `/about`, you simply create a new folder named `about` inside the `app` directory and add a `page.tsx` file to it.

```
app/
├── about/
│   └── page.tsx  // This component renders the UI for the /about route
└── page.tsx      // This component renders the UI for the / route
```

#### Implementing Additional Routes

Creating more routes is as simple as adding more folders with `page.tsx` files. For instance, to add a `/contact` page:

```
app/
├── about/
│   └── page.tsx
├── contact/
│   └── page.tsx  // Renders the UI for the /contact route
└── page.tsx
```

#### Handling Non-Existing Routes (404 Pages)

Next.js has a built-in mechanism for handling routes that don't exist. You can create a custom 404 page by adding a `not-found.tsx` file to the root of your `app` directory. This file will automatically be rendered for any unmatched URL.

For more granular control, you can programmatically trigger a "Not Found" state from within a component by using the `notFound()` function from `next/navigation`. This is useful when, for example, fetching data for a dynamic route returns no result.

```typescript
// app/products/[id]/page.tsx
import { notFound } from 'next/navigation';

async function getProduct(id: string) {
  const res = await fetch(`https://api.example.com/products/${id}`);
  if (!res.ok) {
    return undefined;
  }
  return res.json();
}

export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);

  if (!product) {
    notFound(); // This will render the closest not-found.tsx
  }

  return <h1>{product.name}</h1>;
}
```

### 2. Nested and Dynamic Routes

#### Setting Up Nested Routes

To create nested routes, you simply nest folders within each other. This folder hierarchy directly translates to the URL structure.

**Creating Blog Pages:**

For a URL structure like `/blog/first-post`, you would set up your directories as follows:

```
app/
└── blog/
    ├── page.tsx          // Renders the UI for the /blog route (e.g., a list of posts)
    └── first-post/
        └── page.tsx      // Renders the UI for the /blog/first-post route
```

#### Introduction to Dynamic Routes

Often, you won't know all the possible URL segments ahead of time, especially for content-driven sites like blogs or e-commerce stores. This is where dynamic routes are essential.

**Implementing Dynamic Route Segments:**

You can create a dynamic route segment by wrapping a folder's name in square brackets (e.g., `[slug]`). This `slug` then acts as a parameter that you can access in your component.

For a blog where each post has a unique slug, the structure would be:

```
app/
└── blog/
    └── [slug]/
        └── page.tsx // Renders the UI for any /blog/:slug URL
```

In the `page.tsx` component, the `slug` parameter is passed via the `params` prop:

```typescript
// app/blog/[slug]/page.tsx

export default function BlogPostPage({ params }: { params: { slug: string } }) {
  // params will be { slug: 'some-post-title' }
  // You can use params.slug to fetch the specific blog post data
  return <div>Showing blog post for: <strong>{params.slug}</strong></div>;
}
```

**Pre-building Dynamic Routes with `generateStaticParams`**

For better performance and SEO, you can pre-render these dynamic pages at build time using `generateStaticParams`. This function returns an array of all the `params` (e.g., slugs) that Next.js should generate as static pages during the build process. This is the App Router's equivalent of `getStaticPaths` from the Pages Router.

```typescript
// app/blog/[slug]/page.tsx

// Fetch all possible slugs at build time
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json());

  return posts.map((post: { slug: string }) => ({
    slug: post.slug,
  }));
}

// The rest of the component remains the same
export default function BlogPostPage({ params }: { params: { slug: string } }) {
  return <div>Showing blog post for: <strong>{params.slug}</strong></div>;
}
```

#### Introduction to Nested Dynamic Routes

You can also nest dynamic routes. For example, a route like `/products/[category]/[productId]` can be achieved with the following folder structure:

```
app/
└── products/
    └── [category]/
        └── [productId]/
            └── page.tsx
```

The `params` object in the component will then contain both `category` and `productId`.

### 3. Catch-All and Optional Catch-All Segments

#### Dynamic Routing Simplified

Sometimes a single dynamic segment isn't enough. You might need to handle routes with a variable number of segments, such as for documentation pages (`/docs/getting-started/installation`) or product filtering (`/shop/men/tops/t-shirts`).

#### Setting Up Catch-All Segments

A **Catch-All Segment** is created by adding an ellipsis (`...`) inside the square brackets of a dynamic segment folder (`[...slug]`). This will match the current segment and all subsequent ones.

**Example: A documentation site**

A route file at `app/docs/[...slug]/page.tsx` will match:
*   `/docs/introduction`
*   `/docs/getting-started/installation`
*   `/docs/api/components/button`

**Handling URL Segments in Code:**

For a catch-all route, the `params.slug` property will be an array of all the matched URL segments.

```typescript
// app/docs/[...slug]/page.tsx

export default function DocsPage({ params }: { params: { slug: string[] } }) {
  // If the URL is /docs/getting-started/installation
  // params.slug will be ['getting-started', 'installation']

  return (
    <div>
      <h1>Documentation Page</h1>
      <p>Path: {params.slug.join(' / ')}</p>
    </div>
  );
}
```

#### Optional Catch-All Segments

An **Optional Catch-All Segment** extends the catch-all by also matching the route *without* any segments. This is useful for when a base page is also required for the route. You create one by wrapping the entire folder name in double square brackets (`[[...slug]]`).

**Example: A shop with optional filters**

A route file at `app/shop/[[...filters]]/page.tsx` will match:
*   `/shop` (the base page, `params.filters` will be `undefined`)
*   `/shop/clothing` (`params.filters` will be `['clothing']`)
*   `/shop/clothing/tops` (`params.filters` will be `['clothing', 'tops']`)

#### When to Use Catch-All Segments

*   **Documentation Sites**: Perfect for hierarchical content where the depth is unknown.
*   **E-commerce Category Pages**: Handling complex filtering paths.
*   **CMS-driven pages**: When building pages with completely dynamic URL structures.

**Important Consideration**: Be mindful of route conflicts. A root-level catch-all route (`app/[...slug]/page.tsx`) can conflict with other defined routes like `/about` or even other dynamic routes like `/users/[id]`. It's often better to prefix catch-all routes (e.g., `app/docs/[...slug]/page.tsx`) to avoid ambiguity.